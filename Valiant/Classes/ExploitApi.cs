using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Pipes;
using System.Linq;
using System.Net.Http;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Threading;

namespace Valiant.Classes;

[Flags]
public enum ExploitApiType
{
    EasyExploits = 1,
    WeAreDevs = 2,
    Krnl = 4,
}

public enum InitializeProgress
{
    DownloadingDll,
    DownloadingInjector,
    Initialized
}

public class InitProgressEventArg : EventArgs
{
    public InitializeProgress Progress;
    public bool IsInitialized;
}

public abstract class ExploitApi
{
    public string Directory;
    public bool IsInitialized;
    public Injector Injector;

    public event EventHandler<InitProgressEventArg> InitProgressChanged;

    public abstract ExploitApiType Type { get; }
    public abstract string PipeName { get; }

    public abstract string FileName { get; }

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool WaitNamedPipe(string name, int timeout);

    public bool IsInjected() =>
        WaitNamedPipe(Path.GetFullPath("\\\\.\\pipe\\" + PipeName), 0);

    public void Inject()
    {
        if (!IsInitialized)
            throw new Exception("Please initialize API!");

        Injector.Inject(FileName);
    }

    public bool Execute(string script)
    {
        if (!IsInitialized)
            throw new Exception("Please initialize API!");

        if (!IsInjected())
            return false;

        using var client = new NamedPipeClientStream(".", PipeName, PipeDirection.Out);
        client.Connect();

        using var writer = new StreamWriter(client);
        writer.Write(script);

        return true;
    }

    public abstract Task Initialize();

    public void OnInitProgressChanged(InitializeProgress progress, bool isInit = false)
    {
        InitProgressChanged?.Invoke(this, new InitProgressEventArg
        {
            Progress = progress,
            IsInitialized = isInit
        });
    }

    public static ExploitApi CreateNewInstance(string path, ExploitApiType type, InjectorType injectorType)
    {
        var injector = Injector.CreateNewInstance(injectorType, path);

        return type switch
        {
            ExploitApiType.Krnl => new KrnlApi(path, injector),
            ExploitApiType.WeAreDevs => new WeAreDevsApi(path, injector),
            ExploitApiType.EasyExploits => new EasyExploitsApi(path, injector),
            _ => null
        };
    }
}

public class KrnlApi : ExploitApi
{
    public override ExploitApiType Type => ExploitApiType.Krnl;
    public override string PipeName => "krnlpipe";
    public override string FileName => Path.Combine(Directory, "krnl.dll");

    public KrnlApi(string dir, Injector injector)
    {
        Directory = dir;
        Injector = injector;
    }

    public override async Task Initialize()
    {
        OnInitProgressChanged(InitializeProgress.DownloadingDll);

        using var dllStream = new FileStream(FileName, FileMode.OpenOrCreate, FileAccess.ReadWrite);
        var dll = await App.HttpClient.GetAsync("https://k-storage.com/bootstrapper/files/krnl.dll");

        await dll.Content.CopyToAsync(dllStream);
        OnInitProgressChanged(InitializeProgress.DownloadingDll);

        await Injector.Download();
        OnInitProgressChanged(InitializeProgress.DownloadingInjector);

        IsInitialized = true;
        OnInitProgressChanged(InitializeProgress.Initialized, true);
    }
}

public class WeAreDevsApi : ExploitApi
{
    public override ExploitApiType Type => ExploitApiType.WeAreDevs;
    public override string PipeName => "WeAreDevsPublicAPI_Lua";
    public override string FileName => Path.Combine(Directory, "exploit-main.dll");

    public WeAreDevsApi(string dir, Injector injector)
    {
        Directory = dir;
        Injector = injector;
    }

    public override async Task Initialize()
    {
        OnInitProgressChanged(InitializeProgress.DownloadingDll);
        
        dynamic json = JsonConvert.DeserializeObject(await App.HttpClient.GetStringAsync("https://cdn.wearedevs.net/software/exploitapi/latestdata.json"));
        
        await App.HttpClient.GetFileAsync((string)json!["exploit-module"]["download"], FileName);
        OnInitProgressChanged(InitializeProgress.DownloadingDll);

        await Injector.Download(); 
        OnInitProgressChanged(InitializeProgress.DownloadingInjector);

        IsInitialized = true;
        OnInitProgressChanged(InitializeProgress.Initialized, true);
    }
}

public class EasyExploitsApi : ExploitApi
{
    public override ExploitApiType Type => ExploitApiType.EasyExploits;
    public override string PipeName => "ocybedam";
    public override string FileName => Path.Combine(Directory, "easyexploits.dll");

    public EasyExploitsApi(string dir, Injector injector)
    {
        Directory = dir;
        Injector = injector;
    }

    public override async Task Initialize()
    {
        OnInitProgressChanged(InitializeProgress.DownloadingDll);

        using var dllStream = new FileStream(FileName, FileMode.OpenOrCreate, FileAccess.ReadWrite);
        var content = await App.HttpClient.GetStringAsync("https://easyexploits.com/Module");
        var parsed = content.Split("\r\n".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
        var dll = await App.HttpClient.GetAsync(parsed[1]);

        await dll.Content.CopyToAsync(dllStream);
        OnInitProgressChanged(InitializeProgress.DownloadingDll);

        await Injector.Download();
        OnInitProgressChanged(InitializeProgress.DownloadingInjector);

        IsInitialized = true;
        OnInitProgressChanged(InitializeProgress.Initialized, true);
    }
}